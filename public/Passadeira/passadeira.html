<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js example 01 &mdash; Person Model</title>
    <meta charset="utf-8">
    <style>
        body {
            background-color: #0c0a0f;
            margin: 0px;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
        {
            "imports": {
                 "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                 "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        const fontLoader = new FontLoader();

        fontLoader.load(
            'https://threejs.org/examples/fonts/helvetiker_regular.typeface.json',
            function (font) {

                const simao = new TextGeometry('Simao\n  Santos', {
                    font: font,
                    size: 0.7,
                    height: 0.3,
                    curveSegments: 12,
                    bevelEnabled: false
                });

                const gabriel = new TextGeometry('Gabriel\nGoncalves', {
                    font: font,
                    size: 0.7,
                    height: 0.3,
                    curveSegments: 12,
                    bevelEnabled: false
                });

                const igor = new TextGeometry('   Igor\n  Baltejo', {
                    font: font,
                    size: 0.7,
                    height: 0.3,
                    curveSegments: 12,
                    bevelEnabled: false
                });

                const tiago = new TextGeometry('Tiago\n  Oliveira', {
                    font: font,
                    size: 0.7,
                    height: 0.3,
                    curveSegments: 12,
                    bevelEnabled: false
                });

                const andre = new TextGeometry('Andre\n  Ferreira', {
                    font: font,
                    size: 0.7,
                    height: 0.3,
                    curveSegments: 12,
                    bevelEnabled: false
                });

                const team = new TextGeometry('Meet the Team', {
                    font: font,
                    size: 2,
                    height: 0.3,
                    curveSegments: 12,
                    bevelEnabled: false
                });

                team.computeBoundingBox();
                const minX = team.boundingBox.min.x;
                const rangeX = team.boundingBox.max.x - minX;
                const posAttr = team.getAttribute('position');
                let uvAttr = team.getAttribute('uv');
                if (!uvAttr) {
                    team.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(posAttr.count * 2), 2));
                    uvAttr = team.getAttribute('uv');
                }
                for (let i = 0; i < posAttr.count; i++) {
                    uvAttr.setX(i, (posAttr.getX(i) - minX) / rangeX);
                }

                const canvas = document.createElement('canvas');
                canvas.width = 1024;
                canvas.height = 4;
                const ctx = canvas.getContext('2d');
                const grad = ctx.createLinearGradient(0, 0, 1024, 0);
                grad.addColorStop(0, '#7c3aed');
                grad.addColorStop(0.5, '#9b6bff');
                grad.addColorStop(1, '#a78bfa');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, 1024, 4);

                const gradTex = new THREE.CanvasTexture(canvas);
                gradTex.colorSpace = THREE.SRGBColorSpace;

                const material = new THREE.MeshStandardMaterial({ color: 0xededed });
                const frontMaterial = new THREE.MeshBasicMaterial({ map: gradTex });
                // Side material reacts to light to give 3D depth, but front stays exactly the CSS gradient
                const sideMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x7c3aed, 
                    roughness: 0.5, 
                    metalness: 0.1 
                });
                const titleMaterial = [frontMaterial, sideMaterial];

                const textMesh = new THREE.Mesh(simao, material);

                textMesh.position.set(2, 8, 0);
                scene.add(textMesh);

                const textMesh2 = new THREE.Mesh(gabriel, material);
                textMesh2.position.set(-8, 8, 0);
                scene.add(textMesh2);

                const textMesh3 = new THREE.Mesh(igor, material);
                textMesh3.position.set(-3, 8, 0);
                scene.add(textMesh3);

                const textMesh4 = new THREE.Mesh(tiago, material);
                textMesh4.position.set(7, 8, 0);
                scene.add(textMesh4);

                const textMesh5 = new THREE.Mesh(andre, material);
                textMesh5.position.set(-13, 8, 0);
                scene.add(textMesh5);

                const textMesh6 = new THREE.Mesh(team, titleMaterial);
                textMesh6.position.set(-10, 12, -8);
                scene.add(textMesh6);
            }
        );

        let scene, camera, renderer, loader, controls;
        let andre, gabriel, igor, simon, tiago;
        let starPoints, starSizes, starPhases;

        function load_model(loader, path, scene) {
            return new Promise((resolve, reject) => {
                loader.load(path, (gltf) => {
                    const model = gltf.scene;
                    scene.add(model);
                    model.rotation.y = 180 * (Math.PI / 180);
                    resolve(model);
                }, undefined, (error) => {
                    console.error('An error happened while loading the model:', error);
                    reject(error);
                });
            });

        }

        function add_crosswalk(scene) {

            const geometry = new THREE.PlaneGeometry(15, 2);
            // Crosswalk uses a brighter purple than model bodies.
            const material = new THREE.MeshBasicMaterial({ color: 0xa78bfa, side: THREE.DoubleSide });
            const crosswalk1 = new THREE.Mesh(geometry, material);
            const crosswalk2 = new THREE.Mesh(geometry, material);
            const crosswalk3 = new THREE.Mesh(geometry, material);
            const crosswalk4 = new THREE.Mesh(geometry, material);
            const crosswalk5 = new THREE.Mesh(geometry, material);

            crosswalk1.rotation.x = -Math.PI / 2;
            crosswalk1.rotation.z = Math.PI / 2;
            crosswalk1.position.y = -3.5;
            scene.add(crosswalk1);

            crosswalk2.rotation.x = -Math.PI / 2;
            crosswalk2.rotation.z = Math.PI / 2;
            crosswalk2.position.y = -3.5;
            crosswalk2.position.x = 5.5;
            scene.add(crosswalk2);

            crosswalk3.rotation.x = -Math.PI / 2;
            crosswalk3.rotation.z = Math.PI / 2;
            crosswalk3.position.y = -3.5;
            crosswalk3.position.x = -5;
            scene.add(crosswalk3);

            crosswalk4.rotation.x = -Math.PI / 2;
            crosswalk4.rotation.z = Math.PI / 2;
            crosswalk4.position.y = -3.5;
            crosswalk4.position.x = -10;
            scene.add(crosswalk4);

            crosswalk5.rotation.x = -Math.PI / 2;
            crosswalk5.rotation.z = Math.PI / 2;
            crosswalk5.position.y = -3.5;
            crosswalk5.position.x = 10;
            scene.add(crosswalk5);
        }

        function add_stars(scene) {
            const COUNT = 800;
            const positions = new Float32Array(COUNT * 3);
            starSizes = new Float32Array(COUNT);
            starPhases = new Float32Array(COUNT);

            for (let i = 0; i < COUNT; i++) {
                // place stars on a sphere shell so they appear in all directions
                const radius = 80 + Math.random() * 200;
                const theta = Math.random() * Math.PI * 2;          // horizontal angle
                const phi = Math.acos(2 * Math.random() - 1);     // full vertical range

                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.cos(phi);       // spans above AND below
                positions[i * 3 + 2] = radius * Math.sin(phi) * Math.sin(theta);

                starSizes[i] = Math.random() * 2.5 + 0.5;
                starPhases[i] = Math.random() * Math.PI * 2;
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geo.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));

            // mix of white and purple stars
            const colors = new Float32Array(COUNT * 3);
            for (let i = 0; i < COUNT; i++) {
                if (Math.random() < 0.25) {
                    // purple
                    colors[i * 3] = 0.54;
                    colors[i * 3 + 1] = 0.05;
                    colors[i * 3 + 2] = 0.88;
                } else {
                    // white / cool blue-white
                    colors[i * 3] = 0.85 + Math.random() * 0.15;
                    colors[i * 3 + 1] = 0.85 + Math.random() * 0.15;
                    colors[i * 3 + 2] = 1.0;
                }
            }
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const mat = new THREE.PointsMaterial({
                size: 0.6,
                vertexColors: true,
                transparent: true,
                opacity: 1.0,
                sizeAttenuation: true,
                depthWrite: false,
            });

            starPoints = new THREE.Points(geo, mat);
            scene.add(starPoints);
        }

        async function init() {
            // 1. The SCENE
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0c0a0f);

            loader = new GLTFLoader();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.body.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(-0.5, 7.10, 14.82);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 5, 0);
            controls.enableDamping = true;
            controls.update();



            const ambientLight = new THREE.AmbientLight(0x404040); // soft white light
            scene.add(ambientLight);

            const spotLight = new THREE.SpotLight(0xffffff, 3000);

            spotLight.position.set(0, 20, 5);

            spotLight.target.position.set(0, 0, 0);

            // propriedades importantes
            spotLight.angle = Math.PI / 2;      // abertura do cone
            spotLight.penumbra = 0.4;           // suavidade das bordas
            spotLight.decay = 2;                // queda fÃ­sica da luz
            spotLight.distance = 100;           // alcance

            // sombras (opcional mas recomendado)
            spotLight.castShadow = true;
            spotLight.shadow.mapSize.width = 1024;
            spotLight.shadow.mapSize.height = 1024;

            scene.add(spotLight);
            scene.add(spotLight.target);

            andre = await load_model(loader, './models/Andre.glb', scene);
            gabriel = await load_model(loader, './models/Belito.glb', scene);
            igor = await load_model(loader, './models/Igor.glb', scene);
            simon = await load_model(loader, './models/Simao.glb', scene);
            tiago = await load_model(loader, './models/Tiago.glb', scene);

            // Safe recolor pass: only material tinting, no geometry/rig changes.
            const bodyColor = new THREE.Color(0x7c3aed);
            [andre, gabriel, igor, simon, tiago].forEach((model) => {
                model.traverse((child) => {
                    if (!child.isMesh || !child.material) return;
                    const materials = Array.isArray(child.material) ? child.material : [child.material];
                    const recolored = materials.map((mat) => {
                        if (!mat || !('clone' in mat)) return mat;
                        const clone = mat.clone();
                        // Keep textured materials (e.g., face photos) untouched.
                        if (clone.map) {
                            return clone;
                        }
                        if ('color' in clone && clone.color) {
                            clone.color.copy(bodyColor);
                        }
                        return clone;
                    });
                    child.material = Array.isArray(child.material) ? recolored : recolored[0];
                });
            });

            andre.position.set(-10, 0, 0);
            gabriel.position.set(-5, 0, 0);
            igor.position.set(0, 0, 0);
            simon.position.set(5, 0, 0);
            tiago.position.set(10, 0, 0);

            add_crosswalk(scene);
            add_stars(scene);

            animate();
        }

        let clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // twinkle: modulate each star's size independently
            if (starPoints) {
                const t = clock.getElapsedTime();
                const sizes = starPoints.geometry.attributes.size.array;
                for (let i = 0; i < sizes.length; i++) {
                    const base = starSizes[i];
                    const speed = 0.8 + (i % 7) * 0.3;
                    sizes[i] = base * (0.4 + 0.6 * Math.abs(Math.sin(t * speed + starPhases[i])));
                }
                starPoints.geometry.attributes.size.needsUpdate = true;
            }

            renderer.render(scene, camera);
        }


        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>

</html>